{"basic_builder": {"appname": "JAMF-Pro-addon-for-splunk", "friendly_name": "Jamf Pro Add-on", "version": "2.10.0", "author": "JAMF : Research", "description": "This connects the JAMF Pro Classic API data sources to a Splunk instance", "theme": "#3c6188", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAACmklEQVRYR2P8////f4ZBBBhBDpq1+tide0/eqFDiLgUZ4TsZodYUmQGyH+ygiv5NlLgFrrej0O8PAwMDCyWGUdtBlLgFrHf4OkhGgv9uTqS9MqVBRLUQivI2ua+nJqWIxUG/3n78+u7Zy48C33/+Yv7/j+E3uhpmVmYmQ3VpRmZmJnaqOagkwemLiCAPD5Jl/6etOPLhycv3fP/+/WcmFHKsrMw/m3O8qeegtnzfb0xMjFwgiz99+fG6fe5uof9EOATZoR2FftRJ1NycbJ9rMzx4oYb/qJywie3/fwYmQqGCLk81B8lJCn3LirABh87kZYe+Pn35gZtUx4DUU81BAc56Nyz0FDR+/f77uW7KVlhIkewmqjmoo9DvMwMDA+/5G09ur9x+TpVkl0A1UMVBzEyMf1rzfcHVRe3krd9///nLOaAOSg+zeasoLSQMcgSldSLFIaSnJvkkyttUBuSYU5cf3ly356I6uaFDcaL2d9S7a2mgAK8qehbs+/jm/Rd+qjjoyp3ntzcfuCL69+8/RmwGggRZWVj+8XCxsRhpybyw0FcEtXvgav/++/eteuIWcLanBMCjjBJDQHrvPXn7YdbqowKUmkM1B01YvP/Rizef5QaNgyjNXTCPUCWE3n74erl7/l5dSkMHJZdRYtjkZYc/P335nuzqAmttT66Dfv/5+6l28lY+cvXjrO3JNXDa8sOPH714L0uufqo6aO7a469vP3otSi3HoKehv5++/Pj09x/2ghGkGCT37fsvtjuP3t7fdey6FjUdgpHLOubs+vzh8w+qJExKHEpx5UqJ5dj0jjqIUIiOhtDQDaHG6ds/ff/xm2pVAKGQwCavpSRxM87fTB3ct4cq+MXAwPCPHMOooIeVgYEB3P8HAKcSp6SRyzYwAAAAAElFTkSuQmCC", "visible": true, "tab_version": "4.0.0", "tab_build_no": "0", "build_no": 16}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "JamfModularInput", "interval": "3600", "use_external_validation": true, "streaming_mode_xml": true, "sample_count": "69670", "uuid": "1c09cb214a8442d486dc65548d0c6da3", "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\nimport requests\nimport json\nimport math\nfrom splunklib.modularinput import *\ntry:\n    import xml.etree.cElementTree as ElementTree\nexcept ImportError:\n    import xml.etree.ElementTree as ElementTree\n#import xml.etree.ElementTree as ElementTree\nimport uuid\nimport time\nimport sys, os\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), \"..\", \"lib\"))\nfrom splunklib.modularinput import *\nimport jamf_pro_models\n\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # name_of_the_modular_input = definition.parameters.get('name_of_the_modular_input', None)\n    # jss_url = definition.parameters.get('jss_url', None)\n    # api_call = definition.parameters.get('api_call', None)\n    # search_name = definition.parameters.get('search_name', None)\n    # custom_index_name = definition.parameters.get('custom_index_name', None)\n    # custom_host_name = definition.parameters.get('custom_host_name', None)\n    # username = definition.parameters.get('username', None)\n    # password = definition.parameters.get('password', None)\n    pass\n\ndef collect_events(helper, ew):\n    name_of_the_modular_input = helper.get_arg('name_of_the_modular_input', None)\n    url = helper.get_arg('jss_url', None)\n    api_call = helper.get_arg('api_call', None)\n    search_name = helper.get_arg('search_name', None)\n    username = helper.get_arg('username',None)\n    password = helper.get_arg('password',None)\n    index = helper.get_arg('custom_index_name','main')\n    host = helper.get_arg('custom_host_name','localhost')\n    maxCharLength = 9500\n    call_uuid = uuid.uuid4()\n    \n    #\n    #   Verify JSS URL\n    #\n    if url.__contains__(\"http://\"):\n        url = url.replace(\"http://\",\"\")\n    if url.__contains__(\"https://\"):\n        url = url.replace(\"https://\",\"\")\n    if not url.endswith(\"/\"):\n        url = url + \"/\"\n    url = \"https://\" + url\n    \n        \n    def writeStringTo_Event_withParsing (DATA):\n        root = ElementTree.fromstring(DATA)\n        if root.tag == \"computer\":\n            jamf_computer = jamf_pro_models.jamf_pro_computer()\n            jamf_computer.build_from_string(DATA,\"computer\")\n            string_list = jamf_computer.paginate(create_event_id=True,max_char_length=maxCharLength)\n            for line in string_list:\n                writeStringTo_Event(line)\n            #writeStringTo_Event(DATA)\n        elif root.tag == \"mobile_device\":\n            jamf_mobile = jamf_pro_models.jamf_pro_mobile_device()\n            jamf_mobile.build_from_string(DATA,\"mobile_device\")\n            string_list = jamf_mobile.paginate(create_event_id=True)\n            for line in string_list:\n                writeStringTo_Event(line)\n        else:\n            data = ElementTree.fromstring(DATA)\n            #writeStringTo_Event(ElementTree.tostring(data))\n            writeStringTo_Event(DATA)\n            \n    def writeStringTo_Event( event_string ):\n        #\n        #   This class is to help with the writing to the Splunk Event writer\n        #   \n        #\n        if event_string.__len__() < maxCharLength:\n            xml_event = ElementTree.fromstring(event_string)\n            event = helper.new_event(data=ElementTree.tostring(xml_event,encoding=\"utf-8\", method=\"xml\").decode(), index=index, host=host)\n            #event = helper.new_event(data=event_string, index=index, host=host)\n            ew.write_event(event)\n            return True\n        else:\n            root = ElementTree.Element(\"Error\")\n            ElementTree.SubElement(root, 'error').text = \"The XML was too long\"\n            writeStringTo_Event( ElementTree.tostring(root) )\n            root = ElementTree.fromstring(event_string)\n            children = root.getchildren\n            \n            debug = True\n            if debug:\n                event = helper.new_event(data=str(event_string.__len__()), index=index, host=host)\n                ew.write_event(event)\n            \n            #for n in children\n            #    writeStringTo_Event(ElementTree.tostring(n))\n            #for self in root.find('self'):\n                #writeStringTo_Event( ElementTree.tostring(self))\n\n        return False\n        \n    def writeStringTo_Event_wTime( event_string, event_time ):\n        #\n        #   This class is to help with the writing to the Splunk Event writer\n        #   \n        #\n        if event_string.__len__() < maxCharLength:\n                event = helper.new_event(data=str(event_string), index=index, host=host, time = event_time)\n                ew.write_event(event)\n                return True\n        else:\n            root = ElementTree.Element(\"Error\")\n            ElementTree.SubElement(root, 'error').text = \"The XML was too long\"\n            writeStringTo_Event( ElementTree.tostring(root) )\n            \n            \n            root = ElementTree.fromstring(event_string)\n            children = root.getchildren\n            \n            debug = True\n            if debug:\n                event = helper.new_event(data=str(event_string.__len__()), index=index, host=host)\n                ew.write_event(event)\n            \n            #for n in children\n            #    writeStringTo_Event(ElementTree.tostring(n))\n            #for self in root.find('self'):\n                #writeStringTo_Event( ElementTree.tostring(self))\n\n        return False\n    \n    api_retries = 0\n    \n    def api_get_Call(endPoint):\n\n        #\n        #   JSSResources API Call\n        #\n        \n        api_family = \"\"\n        if endPoint.__contains__(\"uapi/\"):\n            api_family = \"uapi\"\n        if endPoint.__contains__(\"JSSResource/\"):\n            api_family = \"classic\"\n        \n        if api_family == \"classic\":  \n            context = None\n            isDone = False\n            tryCount = 0\n            while not isDone:\n                try:\n                    \n                    r =  requests.get(endPoint, auth=(username, password), headers={'Accept': 'application/xml'}, verify=False)\n                    status_code = r.status_code\n                    resp = r.content\n                    # https://developer.jamf.com/documentation for status code information\n                    if (status_code == 200):\n                        #   Request successful\n                        isDone = True\n                        context = r.content\n                    if (status_code == 201):\n                        #   Request to create or update object successful\n                        context = r.content\n                    if (status_code == 400):\n                        #   Bad request. Verify the syntax of the request specifically the XML body.\n                        pass\n                    if (status_code == 401):\n                        root = ElementTree.Element(\"Error\")\n                        ElementTree.SubElement(root, 'error').text = \"API Auth Error\"\n                        writeStringTo_Event( ElementTree.tostring(root) )\n                        context = ElementTree.Element(\"error\")\n                        isDone = True\n                        pass\n                    if (status_code == 403):\n                        #   Invalid permissions. Verify the account being used has the proper permissions for the object/resource you are trying to access.\n                        pass\n                    if (status_code == 404):\n                        #   Object or resouce is not found\n                        pass\n                    if (status_code == 409):\n                        #   Conflict\n                        pass\n                    if (status_code == 500):\n                        #   Internal server error. Retry the request or contact Jamf support if the error is persistent.\n                        pass\n                    \n                except requests.exceptions.Timeout:\n                    isDone = isDone + 1\n                    if isDone > 3:\n                        root = ElementTree.Element(\"Error\")\n                        ElementTree.SubElement(root, 'error').text = \"Too Many Timeouts\"\n                        writeStringTo_Event( ElementTree.tostring(root) )\n                        context = ElementTree.Element(\"error\")\n                    pass\n                except requests.exceptions.TooManyRedirects:\n                    root = ElementTree.Element(\"Error\")\n                    ElementTree.SubElement(root, 'error').text = \"Too Many Redirects\"\n                    writeStringTo_Event( ElementTree.tostring(root) )\n                    context = ElementTree.Element(\"error\")\n                    pass\n        \n                except requests.exceptions.RequestException as e:\n                    root = ElementTree.Element(\"Error\")\n                    ElementTree.SubElement(root, 'error').text = \"API Error Request Exception\"\n                    writeStringTo_Event( ElementTree.tostring(root) )\n                    context = ElementTree.Element(\"error\")\n                    pass\n                finally:\n                    pass\n    \n        \n        \n        return context\n        #\n        #   End of the API Call Function\n        #\n        \n        \n\n    if api_call == \"computer\":\n        #\n        #   make the API Call\n        #\n        jss_url = \"%sJSSResource/advancedcomputersearches/name/%s\" % (url, search_name)\n        response = requests.get(jss_url, auth=(username, password), headers={'Accept': 'application/xml'},verify=False)\n        tree = ElementTree.fromstring(response.content)\n        #\n        #   Start Advanced Computer\n        #\n        \n        #\n        #   Chunk list is a list of the XML fields that we want to farm out to their own XML data sets\n        #\n        chunk_list = list()\n        #chunk_list.append(\"Applications\")\n        #chunk_list.append(\"Computer_Group\")\n        chunk_list.append(\"Running_Services\")\n        \n        #\n        #   Pull the computers out of the Advanced Computer Search\n        #\n        \n        computers_list = tree.find('computers')\n        computers = computers_list.findall('computer')\n        for computer in computers:\n            \n            #\n            #   keyValue is an Abstract name for the values in Chunk List it will pull it out of the primary XML\n            #\n            for keyValue in chunk_list:\n                if computer.find(keyValue):\n                    keyXML = computer.find(keyValue)\n                    # Get the lenght of the string representation of the XML document\n                    key_char_length = ElementTree.tostring(keyXML).__len__()\n                    if key_char_length < maxCharLength:\n                        #\n                        #   If this is under 10k just go ahead and write to the event reader\n                        #\n                        root = ElementTree.Element(\"computer\")\n                        ElementTree.SubElement(root, 'id').text = computer.find(\"id\").text\n                        root.append(keyXML)\n                        writeStringTo_Event( ElementTree.tostring(root) )\n                    else:\n                        #\n                        #   This is the area for if the already seperated XML is still too large. It will take the Length and use MOD to give the number of XML files it would need to be cut into. I add an additional one just in c\n                        #\n                        chunk_ID = str(uuid.uuid4())\n                        num_XML = math.ceil(key_char_length / maxCharLength) + 1\n                        #\n                        #   Create an array of XML documents\n                        #\n                        root_list = []\n                        for i in range(0, int(num_XML)):\n                            root = ElementTree.Element(keyValue)\n                            root_list.append(root)\n                        #\n                        #   Get a list of the 1st level children in the XML document keeping the same structure\n                        #\n        \n                        #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                        key_chield = keyXML.getchildren()\n                        i = 0\n                        for child in key_chield:\n                            # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                            root_list[int(math.fmod(i, num_XML))].append(child)\n                            i = i + 1\n                        #\n                        #   Iterate through the finished XML documents and write to the event writer.\n                        #\n        \n                        for fin_xml in root_list:\n                            root = ElementTree.Element(\"computer\")\n                            ElementTree.SubElement(root, 'id').text = computer.find(\"id\").text\n                            root.append(fin_xml)\n                            chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                            ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                            ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i)\n                            ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(root_list.__len__())\n                            root.append(chunk_uuid)\n                            \n                            #writeStringTo_Event( ElementTree.tostring(chunk_uuid) )\n                            \n                            writeStringTo_Event( ElementTree.tostring(root) )\n\n                    #\n                    #   Remove the Key Index field from the XML\n                    #\n                    computer.remove(keyXML)\n            #\n            #   Post Data chunking... This *should* be under 10k char now, tune it with chunk list\n            #\n        \n            data = ElementTree.tostring(computer)\n        \n            #\n            #   Check to see if it needs chunking and if it still needs it chunk it on childs\n            #\n            if data.__len__() < maxCharLength:\n                #print (data)\n                writeStringTo_Event( data )\n                \n            else:\n                num_XML = math.ceil(data.__len__() / maxCharLength) + 1\n                #\n                #   Create an array of XML documents\n                #\n                root_list = []\n                chunk_ID = str(uuid.uuid4())\n                for i in range(0, int(num_XML)):\n                    root = ElementTree.Element(\"computer\")\n                    ElementTree.SubElement(root, 'id').text = computer.find(\"id\").text\n                    chunk_uuid = ElementTree.Element(\"pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                    ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i+1)\n                    ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(int(num_XML))\n                    root.append(chunk_uuid)\n                    \n                    root_list.append(root)\n                    \n                #\n                #   Get a list of the 1st level children in the XML document keeping the same structure\n                #\n        \n                #\n                #   Need to remove ID from XML since it will be a duplicate in 1 of them.\n                #\n                \n                computer.remove(computer.find(\"id\"))\n                #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                key_chield = computer.getchildren()\n                i = 0\n                for child in key_chield:\n                    # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                    root_list[int(math.fmod(i, num_XML))].append(child)\n                    i = i + 1\n                #\n                #   Iterate through the finished XML documents and write to the event writer.\n                #\n        \n                for fin_xml in root_list:\n                    writeStringTo_Event( ElementTree.tostring(fin_xml))\n        \n            #\n            # End of Computers For Loop\n            #\n        #\n        # End of Advanced Computers Section\n        #\n\n    elif api_call == \"mobile_device\":\n        jss_url = \"%sJSSResource/advancedmobiledevicesearches/name/%s\" % (url, search_name)\n        response = requests.get(jss_url, auth=(username, password), headers={'Accept': 'application/xml'},verify=False)\n        tree = ElementTree.fromstring(response.content)\n        \n        #\n        #   Chunk list is a list of the XML fields that we want to farm out to their own XML data sets\n        #\n        chunk_list = list()\n        chunk_list.append(\"Display_Name\")\n        chunk_list.append(\"Capacity_MB\")\n        chunk_list.append(\"Device_Locator_Service_Enabled\")\n        \n        \n        mobile_devices_list = tree.find('mobile_devices')\n        mobile_devices = mobile_devices_list.findall('mobile_device')\n        for mobile_device in mobile_devices:\n            #\n            #   keyValue is an Abstract name for the values in Chunk List it will pull it out of the primary XML\n            #\n            for keyValue in chunk_list:\n                if mobile_device.findall(keyValue):\n                    #event = helper.new_event(data=keyValue, index=index, host=host)\n                    #ew.write_event(event)\n                    keyXML = mobile_device.find(keyValue)\n                    # Get the lenght of the string representation of the XML document\n                    key_char_length = ElementTree.tostring(keyXML).__len__()\n                    if key_char_length < maxCharLength:\n                        #\n                        #   If this is under 10k just go ahead and write to the event reader\n                        #\n        \n                        root = ElementTree.Element(\"mobile_device\")\n                        ElementTree.SubElement(root, 'id').text = mobile_device.find(\"id\").text\n                        sub_root =  ElementTree.Element(keyValue)\n                        root.append(keyXML)\n                        #print(ElementTree.tostring(root))\n                        writeStringTo_Event( ElementTree.tostring(root) )\n                    else:\n                        #\n                        #   This is the area for if the already seperated XML is still too large. It will take the Length and use MOD to give the number of XML files it would need to be cut into. I add an additional one just in c\n                        #\n                        \n                        num_XML = math.ceil(key_char_length / maxCharLength) + 1\n                        \n                        \n                        \n                        #\n                        #   Create an array of XML documents\n                        #\n                        chunk_ID = uuid.uuid4()\n                        root_list = []\n                        for i in range(0, int(num_XML)):\n                            root = ElementTree.Element(keyValue)\n                            root_list.append(root)\n                            \n                        #\n                        #   Get a list of the 1st level children in the XML document keeping the same structure\n                        #\n        \n                        #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                        key_chield = keyXML.getchildren()\n                        i = 0\n                        for child in key_chield:\n                            # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                            root_list[int(math.fmod(i, num_XML))].append(child)\n                            i = i + 1\n                        #\n                        #   Iterate through the finished XML documents and write to the event writer.\n                        #\n        \n                        for fin_xml in root_list:\n                            root = ElementTree.Element(\"mobile_device\")\n                            ElementTree.SubElement(root, 'id').text = mobile_device.find(\"id\").text\n                            root.append(fin_xml)\n                            event = helper.new_event(data=ElementTree.tostring(fin_xml), index=index, host=host)\n                \n                            chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                            ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                            ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i+1)\n                            ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(int(num_XML))\n                            \n                            #Finally Write it\n                            writeStringTo_Event( ElementTree.tostring(fin_xml) )\n                    #\n                    #   Remove the Key Index field from the XML\n                    #\n                    mobile_device.remove(keyXML)\n            #\n            #   Post Data chunking... This *should* be under 10k char now, tune it with chunk list\n            #\n        \n            data = ElementTree.tostring(mobile_device)\n        \n            #\n            #   Check to see if it needs chunking and if it still needs it chunk it on childs\n            #\n            if data.__len__() < maxCharLength:\n                writeStringTo_Event( data )\n            else:\n                num_XML = math.ceil(data.__len__() / maxCharLength) + 1\n                #\n                #   Create an array of XML documents\n                #\n                chunk_ID = str(uuid.uuid4())\n                root_list = []\n                for i in range(0, int(num_XML)):\n                    root = ElementTree.Element(\"mobile_device\")\n                    ElementTree.SubElement(root, 'id').text = mobile_device.find(\"id\").text\n                    chunk_uuid = ElementTree.Element(\"pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                    ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i+1)\n                    ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(int(num_XML))\n                    root.append(chunk_uuid)\n                    root_list.append(root)\n                #\n                #   Get a list of the 1st level children in the XML document keeping the same structure\n                #\n        \n                #\n                #   Need to remove ID from XML since it will be a duplicate in 1 of them.\n                #\n                mobile_device.remove(mobile_device.find(\"id\"))\n                #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                key_chield = mobile_device.getchildren()\n                i = 0\n                for child in key_chield:\n                    # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                    root_list[int(math.fmod(i, num_XML))].append(child)\n                    i = i + 1\n                #\n                #   Iterate through the finished XML documents and write to the event writer.\n                #\n        \n                for fin_xml in root_list:\n                    #print(ElementTree.tostring(fin_xml))\n                    event = helper.new_event(data=ElementTree.tostring(fin_xml), index=index, host=host)\n                    writeStringTo_Event( ElementTree.tostring(fin_xml) )\n        \n            #\n            # End of mobile_devices For Loop\n            #\n        #\n        # End of Advanced mobile_devices Section\n        #\n        \n\n        \n    elif api_call == \"custom\":\n\n        if search_name.startswith(\"/\"):\n            search_name = search_name.replace(\"/\",\"\",1)\n            \n        if search_name.endswith(\"/\"):\n            search_name = search_name[:-1]\n            \n        jss_url = url + search_name\n        \n        resp_string = api_get_Call(jss_url)\n        resp_xml = ElementTree.fromstring(api_get_Call(jss_url))\n        \n        if search_name.__contains__(\"/name/\"):\n            writeStringTo_Event( resp_string )\n            return\n        else:\n            children = resp_xml.getchildren()\n            for name in children:\n                if name.findall(\"id\"):\n                    newCall = jss_url +\"/id/\"+name.find(\"id\").text\n                    data = api_get_Call(newCall)\n                    writeStringTo_Event_withParsing( data )\n                    \n    #\n    #   Start Here For Async Tests\n    #\n    \n\n\n    ", "parameters": [{"name": "name_of_the_modular_input", "label": "Name of the Modular Input", "help_string": "Unique Input Name for the data ", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "test"}, {"name": "jss_url", "label": "JSS URL", "help_string": "Base URL for JAMF instance", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "https://trial.jamfcloud.com"}, {"name": "username", "label": "Username", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "service_splunk_api"}, {"name": "password", "label": "Password", "help_string": "", "required": true, "format_type": "password", "default_value": "", "placeholder": "", "type": "password", "value": "JXL63JDNLwNoKtZ"}, {"name": "api_call", "label": "API Call Name", "help_string": "API Call Name", "required": true, "possible_values": [{"label": "Computers", "value": "computer"}, {"label": "Mobile Devices", "value": "mobile_device"}, {"label": "Custom API", "value": "custom"}], "format_type": "radiogroup", "default_value": "", "type": "radiogroup", "value": "custom"}, {"name": "search_name", "label": "Search Name", "help_string": "Preconfigured Advanced Search to call or Custom API call, refer to documentation", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "/JSSResource/mobiledevices"}, {"name": "custom_host_name", "label": "Custom Host Name", "help_string": "", "required": false, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}, {"name": "custom_index_name", "label": "Custom Index Name", "help_string": "", "required": false, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}], "customized_options": [{"name": "name_of_the_modular_input", "value": "test"}, {"name": "jss_url", "value": "https://trial.jamfcloud.com"}, {"name": "username", "value": "service_splunk_api"}, {"name": "api_call", "value": "custom"}, {"name": "search_name", "value": "/JSSResource/computers"}, {"name": "custom_host_name", "value": ""}, {"name": "custom_index_name", "value": ""}], "title": "jamf", "description": "", "type": "customized", "name": "jamf", "data_inputs_options": [{"type": "customized_var", "name": "name_of_the_modular_input", "title": "Name of the Modular Input", "description": "Unique Input Name for the data ", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "jss_url", "title": "JSS URL", "description": "Base URL for JAMF instance", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "username", "title": "Username", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "password", "title": "Password", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "api_call", "title": "API Call Name", "description": "API Call Name", "required_on_edit": false, "required_on_create": true, "possible_values": [{"label": "Computers", "value": "computer"}, {"label": "Mobile Devices", "value": "mobile_device"}, {"label": "Custom API", "value": "custom"}], "format_type": "radiogroup", "default_value": ""}, {"type": "customized_var", "name": "search_name", "title": "Search Name", "description": "Preconfigured Advanced Search to call or Custom API call, refer to documentation", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "custom_host_name", "title": "Custom Host Name", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "custom_index_name", "title": "Custom Index Name", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": ""}]}, {"index": "default", "sourcetype": "Jamf", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "jamfcomputers", "title": "JamfComputers", "description": "Jamf Pro computer collectors", "type": "customized", "parameters": [{"name": "name_of_the_modular_input", "label": "Name of the Modular Input", "help_string": "", "required": false, "format_type": "text", "default_value": "", "placeholder": "Name", "type": "text", "value": "aTestRun"}, {"name": "jss_url", "label": "JSS URL", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "https://trial.jamfcloud.com"}, {"name": "jss_username", "label": "Username", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "service_splunk_api"}, {"required": true, "name": "jss_password", "label": "Password", "placeholder": "", "default_value": "", "help_string": "", "type": "password", "format_type": "password", "value": "JXL63JDNLwNoKtZ"}, {"name": "excludeNoneManaged", "label": "Exclude Non Managed Devices", "help_string": "If a device is not managed Exclude it", "required": false, "format_type": "checkbox", "default_value": true, "type": "checkbox", "value": true}, {"name": "sections", "label": "Sections", "help_string": "General and User_and_Location are included by default: Excluded are Fonts, Services, Package Receipts, Content Caching, iBeacons, Plugins, and Attachments.", "required": false, "possible_values": [{"value": "DISK_ENCRYPTION", "label": "Disk Encryption"}, {"value": "PURCHASING", "label": "Purchasing"}, {"label": "Applications", "value": "APPLICATIONS"}, {"label": "Disk Information", "value": "STORAGE"}, {"label": "Printers", "value": "PRINTERS"}, {"label": "Hardware", "value": "HARDWARE"}, {"label": "Local User Accounts", "value": "LOCAL_USER_ACCOUNTS"}, {"label": "Certificates", "value": "CERTIFICATES"}, {"label": "Security", "value": "SECURITY"}, {"label": "Operating System", "value": "OPERATING_SYSTEM"}, {"label": "Licensed Software", "value": "LICENSED_SOFTWARE"}, {"label": "Software Updates", "value": "SOFTWARE_UPDATES"}, {"label": "Extension Attributes", "value": "EXTENSION_ATTRIBUTES"}, {"label": "Group Memberships", "value": "GROUP_MEMBERSHIPS"}], "format_type": "multi_dropdownlist", "default_value": ["PURCHASING", "APPLICATIONS", "HARDWARE", "OPERATING_SYSTEM", "EXTENSION_ATTRIBUTES", "GROUP_MEMBERSHIPS", "SECURITY"], "placeholder": "", "type": "multi_dropdownlist", "value": ["PURCHASING", "APPLICATIONS", "HARDWARE", "OPERATING_SYSTEM", "EXTENSION_ATTRIBUTES", "GROUP_MEMBERSHIPS", "SECURITY"]}, {"name": "days_since_contact", "label": "Days Since Contact", "help_string": "Exclude devices that haven't been contacted in the above days. Suggest 7, 14, 30, 90 days. Refer to your own environment. \n\n0 = Unlimited", "required": false, "format_type": "text", "default_value": "0", "placeholder": "0", "type": "text", "value": "21"}, {"name": "event_time_format", "label": "Event Time format", "help_string": "Write the \"TIME\" field as either when the device inventoried, was last contacted, or when the Script runs", "required": false, "possible_values": [{"value": "timeAsScript", "label": "Time as Script Run"}], "format_type": "radiogroup", "default_value": "timeAsScript", "type": "radiogroup", "value": "timeAsScript"}, {"name": "host_as_device_name", "label": "Host as Device Name", "help_string": "Writes the devices name as the Host Name.", "required": false, "format_type": "checkbox", "default_value": true, "type": "checkbox", "value": true}, {"name": "use_proxy", "label": "Use proxy", "help_string": "Use the System or Per-App Proxy", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": false}], "data_inputs_options": [{"type": "customized_var", "name": "name_of_the_modular_input", "title": "Name of the Modular Input", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": "Name"}, {"type": "customized_var", "name": "jss_url", "title": "JSS URL", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "jss_username", "title": "Username", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "jss_password", "title": "Password", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "excludeNoneManaged", "title": "Exclude Non Managed Devices", "description": "If a device is not managed Exclude it", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": true}, {"type": "customized_var", "name": "sections", "title": "Sections", "description": "General and User_and_Location are included by default: Excluded are Fonts, Services, Package Receipts, Content Caching, iBeacons, Plugins, and Attachments.", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "DISK_ENCRYPTION", "label": "Disk Encryption"}, {"value": "PURCHASING", "label": "Purchasing"}, {"label": "Applications", "value": "APPLICATIONS"}, {"label": "Disk Information", "value": "STORAGE"}, {"label": "Printers", "value": "PRINTERS"}, {"label": "Hardware", "value": "HARDWARE"}, {"label": "Local User Accounts", "value": "LOCAL_USER_ACCOUNTS"}, {"label": "Certificates", "value": "CERTIFICATES"}, {"label": "Security", "value": "SECURITY"}, {"label": "Operating System", "value": "OPERATING_SYSTEM"}, {"label": "Licensed Software", "value": "LICENSED_SOFTWARE"}, {"label": "Software Updates", "value": "SOFTWARE_UPDATES"}, {"label": "Extension Attributes", "value": "EXTENSION_ATTRIBUTES"}, {"label": "Group Memberships", "value": "GROUP_MEMBERSHIPS"}], "format_type": "multi_dropdownlist", "default_value": ["PURCHASING", "APPLICATIONS", "HARDWARE", "OPERATING_SYSTEM", "EXTENSION_ATTRIBUTES", "GROUP_MEMBERSHIPS", "SECURITY"], "placeholder": ""}, {"type": "customized_var", "name": "days_since_contact", "title": "Days Since Contact", "description": "Exclude devices that haven't been contacted in the above days. Suggest 7, 14, 30, 90 days. Refer to your own environment. \n\n0 = Unlimited", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "0", "placeholder": "0"}, {"type": "customized_var", "name": "event_time_format", "title": "Event Time format", "description": "Write the \"TIME\" field as either when the device inventoried, was last contacted, or when the Script runs", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "timeAsScript", "label": "Time as Script Run"}], "format_type": "radiogroup", "default_value": "timeAsScript"}, {"type": "customized_var", "name": "host_as_device_name", "title": "Host as Device Name", "description": "Writes the devices name as the Host Name.", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": true}, {"type": "customized_var", "name": "use_proxy", "title": "Use proxy", "description": "Use the System or Per-App Proxy", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}], "code": "# encoding = utf-8\n\nimport json\nfrom datetime import datetime, timedelta, timezone\nimport logging\nimport requests\nimport base64\n\nimport time\n\nfrom uapiModels import devices\n\n\n# JamfPro\n\nclass JamfPro:\n    class JamfUAPIAuthToken(object):\n        def __init__(self, jamf_url, username, password, helper):\n            \"\"\"\n            :param jamf_url: Jamf Pro URL\n            :type jamf_url: str\n            :param username: Username for authenticating to JSS\n            :param password: Password for the provided user\n            \"\"\"\n            self.helper = helper\n            self.server_url = jamf_url\n            self._auth = (username, password)\n            self._token = ''\n            self._token_expires = float()\n            if helper.get_proxy() == {}:\n                self.useProxy = False\n            else:\n                self.useProxy = True\n\n            self.get_token()\n\n        @staticmethod\n        def unix_timestamp():\n            \"\"\"Returns a UTC Unix timestamp for the current time\"\"\"\n            epoch = datetime(1970, 1, 1)\n            now = datetime.utcnow()\n            return (now - epoch).total_seconds()\n\n        def headers(self, add=None):\n            \"\"\"\n            :param add: Dictionary of headers to add to the default header\n            :type add: dict\n            \"\"\"\n            header = {'Accept': 'application/json', 'Content-Type': 'application/json'}\n            if hasattr(self, '_auth_token'):\n                header.update(self._auth_token.header)\n\n            if add:\n                header.update(add)\n\n            return header\n\n        @property\n        def token(self):\n            if (self._token_expires - self.unix_timestamp()) < 0:\n                logging.warning(\"JSSAuthToken has expired: Getting new token\")\n                self.get_token()\n            elif (self._token_expires - self.unix_timestamp()) / 60 < 5:\n                logging.info(\"JSSAuthToken will expire soon: Refreshing\")\n                self.refresh_token()\n\n            return self._token\n\n        @token.setter\n        def token(self, new_token):\n            self._token = new_token\n\n        @property\n        def header(self):\n            return {'Authorization': 'Bearer {}'.format(self.token)}\n\n        def __repr__(self):\n            return \"<JSSAuthToken(username='{}')>\".format(self._auth[0])\n\n        def get_token(self):\n            url = self.server_url + 'uapi/auth/tokens'\n            logging.info(\"JSSAuthToken requesting new token\")\n            #response = requests.post(url, auth=self._auth)\n\n            userpass = self._auth[0] + ':' + self._auth[1]\n            encoded_u = base64.b64encode(userpass.encode()).decode()\n            headers = {\"Authorization\": \"Basic %s\" % encoded_u}\n\n            response = self.helper.send_http_request(url=url,\n                                                     method=\"POST\",\n                                                     headers=headers,\n                                                     use_proxy=self.useProxy)\n            if response.status_code != 200:\n                raise Exception\n\n            self._set_token(response.json()['token'], response.json()['expires'])\n\n        def _set_token(self, token, expires):\n            \"\"\"\n            :param token:\n            :type token: str\n            :param expires:\n            :type expires: int\n            \"\"\"\n            self.token = token\n            self._token_expires = float(expires) / 1000\n\n        def about_token(self):\n            url = self.server_url + 'uapi/v1/auth'\n            response = requests.get(url, headers=self.headers())\n            return response.json()\n\n    def __init__(self, jamf_url=\"\", jamf_username=\"\", jamf_password=\"\", helper=None):\n        self.helper = helper\n        self.url = jamf_url\n        self.username = jamf_username\n        self.password = jamf_password\n        self._authToken = self.JamfUAPIAuthToken(jamf_url=jamf_url, username=jamf_username, password=jamf_password,\n                                                 helper=helper)\n\n        if helper.get_proxy() == {}:\n            self.useProxy = False\n        else:\n            self.useProxy = True\n        self.headers = {\n            'Accept': 'application/json',\n            'Authorization': self._authToken.header['Authorization'],\n        }\n\n    def _url_get_call(self, URL=\"\"):\n        \"\"\"\n\n        :param URL:\n        :return:\n        \"\"\"\n        url = URL\n        response_dict = None\n        for i in range(0, 3):\n            try:\n                if response_dict is None:\n                    response = self.helper.send_http_request(url=url,\n                                                             method=\"GET\", payload=None,\n                                                             headers=self.headers, verify=True,\n                                                             use_proxy=self.useProxy, timeout=30)\n\n                    response_dict = json.loads(response.content)\n                    if response.status_code != 200:\n                        pass\n            except:\n                response_dict = None\n\n        return response_dict\n\n    def _filter_computer(self, filters={}, computer={}) -> bool:\n        \"\"\"\n        Returns if to include the computer or not\n        :param filters: Dictionary of the Filters for a Device\n        :param computer: UAPI Computer Details\n        :return: Boolean, Reason for False\n        \"\"\"\n        # Device Managed\n        if 'managed' in filters:\n            if computer['general']['remoteManagement']['managed'] != filters['managed']['value']:\n                return False, \"notManaged\"\n\n        # Last Contact\n        if 'lastContactTime' in filters:\n            try:\n                computerTime = datetime.strptime(computer['general']['lastContactTime'], \"%Y-%m-%dT%H:%M:%S.%fZ\")\n            except ValueError:\n                computerTime = datetime.strptime(computer['general']['lastContactTime'], \"%Y-%m-%dT%H:%M:%SZ\")\n            except:\n                return False, \"no Contact Time\"\n\n            testTime = datetime.strptime(filters['lastContactTime']['value'], \"%Y-%m-%dT%H:%M:%S.%fZ\")\n\n            if filters['lastContactTime']['operator'] == '>':\n                if computerTime > testTime:\n                    pass\n                else:\n                    return False, \"contactTimeBoundary\"\n\n        # Last Report\n        if 'lastReportTime' in filters:\n            try:\n                if computer['general']['reportDate'] == None:\n                    return False, \"NoReportDate\"\n                computerTime = datetime.strptime(computer['general']['reportDate'], \"%Y-%m-%dT%H:%M:%S.%fZ\")\n            except ValueError:\n                computerTime = datetime.strptime(computer['general']['reportDate'], \"%Y-%m-%dT%H:%M:%SZ\")\n\n            testTime = datetime.strptime(filters['lastReportTime']['value'], \"%Y-%m-%dT%H:%M:%S.%fZ\")\n\n            if filters['lastReportTime']['operator'] == '>':\n                if computerTime > testTime:\n                    pass\n                else:\n                    return False, \"reportTimeBoundary\"\n\n        # Base Case, Never got a False\n        return True, None\n\n    def _build_url(self, sections=[], page_number=1, page_size=200, endpoint=\"\", sortKey=\"\"):\n        response = self.url\n        response = response + endpoint\n        section_s = \"?\"\n        for section in sections:\n            if section == sections[0]:\n                section_s = section_s + f\"section={section}\"\n            else:\n                section_s = section_s + f\"&section={section}\"\n        response = response + section_s\n        response = response + f\"&page={page_number}&page-size={page_size}\"\n        if sortKey != \"\":\n            response = response + sortKey\n        return response\n\n    def getAllComputers(self, filters: dict, sections: list, sortKey: str):\n        endpoint = \"uapi/v1/computers-inventory\"\n        page_number = 0\n        page_size = 200\n        another_page = True\n        computers = []\n\n        while another_page:\n            url = self._build_url(sections=sections, page_size=page_size, page_number=page_number, endpoint=endpoint,\n                                  sortKey=sortKey)\n            try:\n                p_computers = self._url_get_call(URL=url)['results']\n            except KeyError:\n                p_computers = []\n\n            if p_computers.__len__() == 0:\n                another_page = False\n            else:\n                for computer in p_computers:\n                    addComputer, reason = self._filter_computer(filters=filters, computer=computer)\n                    if addComputer:\n                        computers.append(computer)\n                    else:\n                        if reason == \"contactTimeBoundary\":\n                            another_page = False\n                        if reason == \"reportTimeBoundary\":\n                            another_page = False\n                page_number = page_number + 1\n        return computers\n\n    def getComputerDetails(self, jss_id=0, ssn=\"\"):\n        \"\"\"\n        This function will return Current Details about a computer\n        :param jss_id: INT jss_ID\n        :param ssn: String of the SSN\n        :return: JSON/DICT of the Computer\n        \"\"\"\n\n        if jss_id > 0 and ssn == \"\":\n            endpoint = f\"uapi/v1/computers-inventory-detail/{jss_id}\"\n            response = self._url_get_call(URL=self.url + endpoint)\n            return response\n\n    def getComputerApplicationUsage(self, jss_id=0, days=21, appName=\"\"):\n        tod = datetime.now()\n        d = timedelta(days=days)\n        a = tod - d\n        start = a.strftime(\"%Y-%m-%d\")\n        end = tod.strftime(\"%Y-%m-%d\")\n\n        endpoint = f\"JSSResource/computerapplicationusage/id/{jss_id}/{start}_{end}\"\n        response = self._url_get_call_JSSResource(URL=self.url + endpoint)\n        if appName != \"\":\n            # Strip out other Applications\n            for appUsageDay in response['computer_application_usage']:\n                appUsageDay['apps'] = list(filter(lambda i: i['name'].lower() == appName, appUsageDay['apps']))\n\n        return response\n\n\n# Static Variables\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # name_of_the_modular_input = definition.parameters.get('name_of_the_modular_input', None)\n    # jss_url = definition.parameters.get('jss_url', None)\n    # username = definition.parameters.get('username', None)\n    # password = definition.parameters.get('password', None)\n    # multiple_dropdown = definition.parameters.get('multiple_dropdown', None)\n    # radio_buttons = definition.parameters.get('radio_buttons', None)\n    # run_time = definition.parameters.get('run_time', None)\n    # write_computer_diffs = definition.parameters.get('write_computer_diffs', None)\n    pass\n\n\ndef collect_events(helper, ew):\n    \"\"\"\n    This is the main execution function\n    \"\"\"\n    errors = []\n    proxy_settings = helper.get_proxy()\n    start_time = time.time()\n    settings = {\n        \"jamfSettings\": {\n            \"jssUrl\": helper.get_arg('jss_url', None),\n            \"jssUsername\": helper.get_arg('jss_username', None),\n            \"jssPassword\": helper.get_arg('jss_password', None),\n        },\n        \"computerCollection\": {\n            \"details\": helper.get_arg('computer_collection_details', None),\n            \"daysSinceContact\": helper.get_arg('days_since_contact', None),\n            \"excludeNoneManaged\": helper.get_arg('excludeNoneManaged', None),\n            \"sections\": helper.get_arg('sections', None)\n        },\n        \"eventWriter\": {\n            \"hostAsDeviceName\": helper.get_arg('host_as_device_name', None),\n            \"eventTimeFormat\": helper.get_arg('event_time_format', None)\n        },\n        \"outbound\": {\n            \"use_proxy\": helper.get_arg('use_proxy', None),\n            \"verifyTLS\": True,\n            \"retryCount\": 3,\n            \"timeOut\": 60\n        }\n    }\n    # Clean Up Checks\n\n    # Jamf URL\n    if str(settings['jamfSettings']['jssUrl'])[-1] != '/':\n        settings['jamfSettings']['jssUrl'] = settings['jamfSettings']['jssUrl'] + '/'\n\n    #\n    # Functions:\n    #\n\n    def writeEvent(thisEvent=None):\n        \"\"\"\n        \"\"\"\n        #\n        #   This class is to help with the writing to the Splunk Event writer\n        #\n        #\n\n        if \"index\" in thisEvent:\n            index = thisEvent['index']\n            del thisEvent['index']\n        else:\n            index = \"main\"\n\n        if \"host\" in thisEvent:\n            host = thisEvent['host']\n            del thisEvent['host']\n        else:\n            host = \"Jamf-TA-AddOn\"\n\n        if \"sourcetype\" in thisEvent:\n            sourcetype = thisEvent['sourcetype']\n            del thisEvent['sourcetype']\n        else:\n            sourcetype = \"_json\"\n\n        if \"time\" in thisEvent:\n            eventTime = thisEvent['time']\n            del thisEvent['time']\n        else:\n            eventTime = time.time()\n\n        if \"source\" in thisEvent:\n            source=thisEvent['source']\n            del thisEvent['source']\n        else:\n            source = \"jssInventory\"\n\n        event = helper.new_event(data=json.dumps(thisEvent, ensure_ascii=False), source=source, time=eventTime, index=index, host=host,\n                                 sourcetype=sourcetype)\n        ew.write_event(event)\n        return True\n\n    def getAllComputers():\n        # Get the UAPI KEY:\n        jss = JamfPro(jamf_url=settings['jamfSettings']['jssUrl'],\n                      jamf_username=settings['jamfSettings']['jssUsername'],\n                      jamf_password=settings['jamfSettings']['jssPassword'],\n                      helper=helper)\n\n        FILTERS = {}\n        if settings['computerCollection']['excludeNoneManaged']:\n            FILTERS['managed'] = {'value': True}\n        if settings['computerCollection']['daysSinceContact'] != str(0):\n            try:\n                time_s = datetime.now(timezone.utc) - timedelta(\n                    days=int(settings['computerCollection']['daysSinceContact']))\n                FILTERS['lastContactTime'] = {\n                    'value': time_s.strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\"),\n                    'operator': '>'\n                }\n            except:\n                errors.append(\n                    {'type': 'Filter Value Error', 'value': settings['computerCollection']['daysSinceContact']})\n\n        sections = settings['computerCollection']['sections']\n\n        requiredSections = ['GENERAL', 'USER_AND_LOCATION', 'HARDWARE']\n\n        for requiredSection in requiredSections:\n            if requiredSection not in sections:\n                sections.append(requiredSection)\n\n        computers = jss.getAllComputers(filters=FILTERS, sections=sections, sortKey=\"&sort=general.reportDate%3Adesc\")\n\n        return computers\n\n    # Collect Computers\n    theseComputers = getAllComputers()\n\n    # Modify computers\n    meta_keys = ['supervised', 'managed', 'name', 'serial_number', 'udid', 'id', 'assigned_user', 'department',\n                 'building', 'room', 'eventID']\n\n    for computer in theseComputers:\n        newComputer = devices.JamfComputer(computerDetails=computer, source=\"uapi\")\n\n        if settings['eventWriter']['eventTimeFormat'] == \"timeAsScript\":\n            timeAs = \"script\"\n        if settings['eventWriter']['eventTimeFormat'] == \"timeAsReport\":\n            timeAs = \"report\"\n\n        events = newComputer.splunk_hec_events(meta_keys=meta_keys,\n                                               nameAsHost=settings['eventWriter']['hostAsDeviceName'], timeAs=timeAs)\n        for event in events:\n            writeEvent(event)\n        pass\n", "customized_options": [{"name": "name_of_the_modular_input", "value": "aTestRun"}, {"name": "jss_url", "value": "https://jamf.jamfcloud.com"}, {"name": "jss_username", "value": "api-splunk"}, {"name": "excludeNoneManaged", "value": true}, {"name": "sections", "value": ["DISK_ENCRYPTION", "PURCHASING", "APPLICATIONS", "STORAGE", "PRINTERS", "HARDWARE", "LOCAL_USER_ACCOUNTS", "CERTIFICATES", "SECURITY", "OPERATING_SYSTEM", "LICENSED_SOFTWARE", "SOFTWARE_UPDATES", "EXTENSION_ATTRIBUTES", "GROUP_MEMBERSHIPS"]}, {"name": "days_since_contact", "value": "21"}, {"name": "event_time_format", "value": "timeAsScript"}, {"name": "host_as_device_name", "value": true}, {"name": "use_proxy", "value": false}], "uuid": "808639f28b8e4cf1b8a3a23387421ca5", "sample_count": "0"}]}, "field_extraction_builder": {"JamfModularInput": {"is_parsed": true, "data_format": "xml"}, "Jamf": {"data_format": "json"}}, "global_settings_builder": {"global_settings": {"proxy_settings": {"proxy_type": "http"}, "log_settings": {"log_level": "DEBUG"}, "credential_settings": []}}, "sourcetype_builder": {"JamfModularInput": {"metadata": {"extractions_count": 0, "data_input_name": "jamf", "cims_count": 0, "event_count": 0}}, "Jamf": {"metadata": {"event_count": 0, "data_input_name": "jamfcomputers", "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_finished", "validation_id": "v_1631724017_54", "progress": 1.0}}